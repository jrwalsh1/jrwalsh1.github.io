<!DOCTYPE html>
<html prefix="
og: http://ogp.me/ns#
article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Permutations and the N Queens Problem | Math and Data</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="http://jrwalsh1.github.io/posts/permutations-and-the-n-queens-problem/">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'center' to center equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}},
        linebreaks: { automatic: true }
    }
});
</script><!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Jon Walsh">
<meta property="og:site_name" content="Math and Data">
<meta property="og:title" content="Permutations and the N Queens Problem">
<meta property="og:url" content="http://jrwalsh1.github.io/posts/permutations-and-the-n-queens-problem/">
<meta property="og:description" content="I ran across an interesting problem recently while studying some recursive algorithms: the N Queens Problem.  Given an $N$-by-$N$ chessboard, the problem is to determine the number of configurations o">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2015-08-12T15:29:14-07:00">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="chess">
<meta property="article:tag" content="combinatorics">
<meta property="article:tag" content="mathjax">
<meta property="article:tag" content="permutations">
<meta property="article:tag" content="python">
<meta property="article:tag" content="recursion">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<div class="container">
    <div class="page-header">
        <ul class="nav nav-pills pull-right">
<li>
    <a href="index.md" id="sourcelink">Source</a>
    </li>
            
        </ul>
<a href="http://jrwalsh1.github.io/">
            <h2 class="text-muted">
                <span id="blog-title"><strong>Math and Data</strong></span>
            </h2>
        </a>
    </div> <!-- ./page-header -->
</div> <!-- ./container -->

<!-- End of Menubar -->

<div class="container" id="content" role="main">
    <div class="row">
        <div class="col-sm-3 col-md-2">
            <ul class="nav nav-pills nav-stacked">
<li>
<a href="../../about/index.html">About</a>
                </li>
<li>
<a href="../../categories/">Tags</a>
                </li>
<li>
<a href="../../rss.xml">RSS feed</a>

                
            </li>
</ul>
</div> <!-- ./col -->
        <div class="col-sm-9 col-md-10">
            <div class="body-content">
                <!--Body content-->
                <div class="row">
                    
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Permutations and the N Queens Problem</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Jon Walsh</span></p>
            <p class="dateline"><a href="." rel="bookmark"><time class="published dt-published" datetime="2015-08-12T15:29:14-07:00" itemprop="datePublished" title="2015-08-12 15:29">2015-08-12 15:29</time></a></p>
                <p class="commentline">            <a href=".#disqus_thread" data-disqus-identifier="cache/posts/permutations-and-the-n-queens-problem.html">Comments</a>


                    </p>
<p class="sourceline"><a href="index.md" id="sourcelink">Source</a></p>

        </div>
        
    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>I ran across an interesting problem recently while studying some recursive algorithms: the N Queens Problem.  Given an $N$-by-$N$ chessboard, the problem is to determine the number of configurations of $N$ queens on the chessboard that do not attack each other.  That is, for a valid configuration (solution) no two queens share the same row (rank), column (file), or diagonal.</p>
<p>For $N = 1$ there is a trivial solution, but none exist for $N = 2$ or $3$.  $N = 4$ has two solutions:</p>
<div> $$
\begin{matrix}
- &amp; Q &amp; - &amp; - \\\
- &amp; - &amp; - &amp; Q \\\
Q &amp; - &amp; - &amp; - \\\
- &amp; - &amp; Q &amp; -
\end{matrix}
\qquad \text{ and } \qquad
\begin{matrix}
- &amp; - &amp; Q &amp; - \\\
Q &amp; - &amp; - &amp; - \\\
- &amp; - &amp; - &amp; Q \\\
- &amp; Q &amp; - &amp; -
\end{matrix}
$$ </div>

<p><br></p>
<p>And they grow quickly from there.  For $N = 8$ there are $92$ solutions (many related by symmetry) -- here's one:</p>
<div> $$
\begin{matrix}
- &amp; - &amp; Q &amp; - &amp; - &amp; - &amp; - &amp; - \\\
- &amp; - &amp; - &amp; - &amp; - &amp; Q &amp; - &amp; - \\\
- &amp; - &amp; - &amp; - &amp; - &amp; - &amp; - &amp; Q \\\
Q &amp; - &amp; - &amp; - &amp; - &amp; - &amp; - &amp; - \\\
- &amp; - &amp; - &amp; Q &amp; - &amp; - &amp; - &amp; - \\\
- &amp; - &amp; - &amp; - &amp; - &amp; - &amp; Q &amp; - \\\
- &amp; - &amp; - &amp; - &amp; Q &amp; - &amp; - &amp; - \\\
- &amp; Q &amp; - &amp; - &amp; - &amp; - &amp; - &amp; -
\end{matrix}
$$ </div>

<p><br></p>
<p>and for $N = 15$ there are $2279184$ solutions.  It appears the number of solutions has not been computed for more than $N = 26$, where there are more than $22$ quadrillion solutions!  No general formula for the number solutions is known, nor is the asymptotic behavior.</p>
<!-- TEASER_END -->

<p>Even though the problem isn't well understood analytically, it's fairly straightforward to design an algorithm to compute the number of solutions.  A recursive algorithm naturally comes to mind, and one may even think a dynamic programming algorithm on $N$ would be useful.  However, by considering the simplest nontrivial cases, you can see that dynamic programming doesn't really work: only certain solutions for the $N-1$ case naturally extend to solutions for the $N$ case.</p>
<p>A brute force algorithm goes as follows:</p>
<ul>
<li>Generate all possible permutations of $1, \ldots, N$.  Set a counter to $0$.</li>
<li>For each permutation ${\pi_1, \ldots, \pi_N}$, place a queen on row $i$ and column $\pi_i$, for $i = 1, \ldots, N$.</li>
<li>Test if this configuration is valid; if so, increment the counter.</li>
</ul>
<p>We have set up this algorithm so that by default no queen is on the same row or column as another queen.  This means that in step 3 we only need to check the diagonals.  This algorithm will find all solutions but is extremely inefficient.  For $N = 8$ there are $8! = 40320$ possibilities to try but only $92$ solutions; for $N = 12$ there are $12! = 479001600$ possibilities but only $14200$ solutions!  We can do better -- the brute force algorithm ends up trying lots of solutions that don't work for the same reason (e.g. the queens on the first two rows are on the same diagonal).</p>
<p>The standard approach is a <em>backtracking algorithm</em>: one starts laying down queens on the chessboard (say row-by-row) in some systematic way that would cover all $N!$ configurations.  Once a queen is placed on a given row that invalidates the configuration, it is moved along that row until the solution becomes valid.  By repeatedly doing this, one can construct all possible solutions.  This algorithm is much more efficient than the brute force algorithm, since one avoids lots of invalid solutions quickly.  As far as I know there is no constructive solution to the problem -- no way to only generate solutions directly without using an iterative procedure that sometimes encounters invalid configurations.</p>
<p>I will describe an algorithm here that uses a slick permutation generator to solve the $N$ queens problem.  It is also non-constructive, but it appears more efficient than the backtracking algorithm.  First, let's talk about permutations!</p>
<h2><span style="color:blue">Permutations</span></h2>
<p>Permutations are easy: they're easy to write down and can be generated recursively.  To generate the permutations of 3 elements,</p>
<div> $$
\{1, 2, 3\} ,\, \{1, 3, 2\} ,\, \{2, 1, 3\} ,\, \{2, 3, 1\} ,\, \{3, 1, 2\} ,\, \{3, 2, 1\} \,,
$$ </div>

<p><br></p>
<p>we start with permutations of two elements,</p>
<div> $$
\{1, 2\} ,\, \{2, 1\} \,,
$$ </div>

<p><br></p>
<p>and insert the third element at all possible positions in each permutation:</p>
<div> $$
\begin{align}
\{1, 2\} \; &amp;\to \; \{1, 2, 3\} ,\, \{1, 3, 2\} ,\, \{3, 1, 2\} \\\
\{2, 1\} \; &amp;\to \; \{2, 1, 3\} ,\, \{2, 3, 1\} ,\, \{3, 2, 1\}
\end{align}
$$ </div>

<p><br></p>
<p>We could loop like this to generate all possible permutations.  It's not clear how this relates to the $N$ queens problem if we want to do better than the brute force algorithm.</p>
<p>Here's another algorithm to generate permutations of $n$ objects.  I'll call it the <em>branch-swap algorithm</em>:</p>
<ul>
<li>Start with a default ordering, e.g. $\pi_0 = {1, 2, \ldots , n}$.  Define a list $L$ to hold the permutations; add $\pi_0$.</li>
<li>Define a function $p_{\rm swap}$ taking as inputs an ordering $\pi = {\pi_1, \ldots, \pi_n}$, and index $i$, and the list of permutations $L$.  For each index $j &gt; i$,<ul>
<li>Generate an ordering $\pi_{i\leftrightarrow j}$ by swapping $\pi_i$ and $\pi_j$ in $\pi$.</li>
<li>Add $\pi_{i\leftrightarrow j}$ to $L$.</li>
<li>Call $p_{\rm swap}$ on $\pi_{i\leftrightarrow j}$ for all indices $k &gt; i$.</li>
</ul>
</li>
<li>Call $p_{\rm swap}$ on $\pi_0$ for all indices.</li>
</ul>
<p>The index in $p_{\rm swap}$ tracks the point up to which we've swapped in elements to generate all possible permutations -- and that provides a nice advantage in cases where we'll want to throw out permutations as we generate them.</p>
<p>Here's a diagram of the algorithm for the case of 4 elements $\{a, b, c, d\}$:</p>
<div style="text-align: center;"><img src="../../images/branch-swap.png" alt="branch-swap, 4 elements" width="900"></div>

<p><br></p>
<p>Each vertical line below a permutation is the call to $p_{\rm swap}$, and the horizontal lines from it (the branches) are the permutations generated.  The dotted horizontal lines are the recursive calls to $p_{\rm swap}$ with higher indices to swap from.</p>
<p>The feature of this algorithm is that each branch fixes a prefix of the set of objects: if we are calling $p_{\rm swap}$ on a permutation $\pi$ and we are swapping at index $i$, then <em>all</em> subsequent permutations generated have the same values for indices up (but not including) $i$.  You can see this in the figure, and it would become much more evident in the case of 5 (or more) elements.</p>
<p>The sequence of permutations that comes out of the algorithm in this case is (reading top-to-bottom, then left-to-right):</p>
<div> $$
\{a, b, c, d\} \qquad \qquad \{b, a, d, c\} \qquad \qquad \{c, b, d, a\} \qquad \qquad \{d, b, a, c\} \\\
\{b, a, c, d\} \qquad \qquad \{c, b, a, d\} \qquad \qquad \{d, b, c, a\} \qquad \qquad \{a, c, b, d\} \\\
\{b, c, a, d\} \qquad \qquad \{c, d, a, b\} \qquad \qquad \{d, c, a, b\} \qquad \qquad \{a, c, d, b\} \\\
\{b, c, d, a\} \qquad \qquad \{c, d, b, a\} \qquad \qquad \{d, c, b, a\} \qquad \qquad \{a, d, c, b\} \\\
\{b, d, c, a\} \qquad \qquad \{c, a, b, d\} \qquad \qquad \{d, a, c, b\} \qquad \qquad \{a, d, b, c\} \\\
\{b, d, a, c\} \qquad \qquad \{c, a, d, b\} \qquad \qquad \{d, a, b, c\} \qquad \qquad \{a, b, d, c\}
$$ </div>

<p><br></p>
<p>Here's some <code>python</code> code for this algorithm:</p>
<pre class="code literal-block"><span class="c"># generator for branch-swap permutation algorithm</span>
<span class="k">def</span> <span class="nf">gen_branch_perms</span><span class="p">(</span><span class="n">base</span><span class="p">):</span>
   <span class="k">yield</span> <span class="n">base</span>
   <span class="c"># recurse for all swap indices up to the next-to-last</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">yield_branch</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
         <span class="k">yield</span> <span class="n">p</span>

<span class="c"># branch-swap permutation algorithm, recursion generator</span>
<span class="k">def</span> <span class="nf">yield_branch</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
   <span class="c"># create all single swaps of index with equal or greater indices</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)):</span>
      <span class="n">perm_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
      <span class="n">perm_i</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">perm_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
      <span class="k">yield</span> <span class="n">perm_i</span>
      <span class="c">## call the swap recursion with all greater indices, up to the 2nd to last</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
         <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">yield_branch</span><span class="p">(</span><span class="n">perm_i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">p</span>
</pre>


<p><br></p>
<p>The first generator performs the outer loop in the algorithm, while the second performs the recursion (second) step.  In <code>C++</code>, the corresponding functions look like:</p>
<pre class="code literal-block"><span class="c1">// get the permutations of a string</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">get_perms</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// output container</span>
   <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">perms</span><span class="p">;</span>
   <span class="n">perms</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>

   <span class="c1">// call the recursion</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">base</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">permutation_step</span><span class="p">(</span><span class="n">perms</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="n">perms</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// recursion function</span>
<span class="c1">// works by swapping a given index with all others greater than it (separately)</span>
<span class="kt">void</span> <span class="n">permutation_step</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">perms</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">perm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// swap for all larger indices</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">perm</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">perm_i</span> <span class="o">=</span> <span class="n">perm</span><span class="p">;</span>
      <span class="n">perm_i</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">perm_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
      <span class="n">perms</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">perm_i</span><span class="p">);</span>
      <span class="c1">// call the permutation recursion again if we haven't reached the end of the list</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">perm</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">perm_i</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">permutation_step</span><span class="p">(</span><span class="n">perms</span><span class="p">,</span> <span class="n">perm_i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre>


<p><br></p>
<p>These return a vector of all permutations instead of an iterator.  In both implementations, it's useful to note that the permutations are added as the algorithm progresses.  When we enter a branch where we fix the first $i$ elements (via a swap), we add the permutation reached that point to the list of found permutations (or just yield it in the case of the python implementation).  Other permutations with the same first $i$ elements but different following elements are found through later swaps and added then.</p>
<h4><span style="color:blue">Parsimony</span></h4>
<p>There's a slight modification of this algorithm which is slightly slower but is easier to conceptualize, more commonly known and used, and produces more concise code.  In the above version, once we make a swap to generate a permutation $\pi$ we will always interchange elements to create new permutations, and never perform what amounts to the identity operation on $\pi$.  The penalty for this is we have to have the secondary loop in the recursion function that creates branches of the algorithm where we swap at subsequently higher indices.  What if we eliminate this, and call the swap loop on a given index $i$ not from $i + 1$ up, but from $i$ up?  Well, we'll be performing the identity operation sometimes, and so we'll carry a permutation around as we push the index we're swapping out to the end of the list.  The <code>python</code> implementation of this version of the algorithm is</p>
<pre class="code literal-block"><span class="c"># generator for straight branch-swap permtuation algorithm</span>
<span class="k">def</span> <span class="nf">gen_straight_branch_perms</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
   <span class="c"># if we're at the last index, save and stop</span>
   <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">yield</span> <span class="n">perm</span>
   <span class="c"># create all single swaps of index with equal or greater indices</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)):</span>
      <span class="n">perm_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
      <span class="n">perm_i</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">perm_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
      <span class="c">## call the swap recursion with the next index</span>
      <span class="k">for</span> <span class="n">perm_j</span> <span class="ow">in</span> <span class="n">gen_straight_branch_perms</span><span class="p">(</span><span class="n">perm_i</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
         <span class="k">yield</span> <span class="n">perm_j</span>
</pre>


<p><br></p>
<p>I'll give code using this version of the algorithm for the $N$ queens problem, but we'll see how the two versions compare.  I'll call this version the <em>straight branch-swap</em> algorithm, because if you draw the equivalent diagram for this version to the figure above you get a vertical ordering.</p>
<h2><span style="color:blue">The N Queens Problem</span></h2>
<p>Let's use the representation in the brute force algorithm above: a permutation $\pi_i = { \pi_1, \ldots, \pi_N}$ is a board with queens at (row, column) positions $(1, \pi_1), (2, \pi_2), \ldots , (N, \pi_N)$.  For example, for $N = 4$, one of the solutions is represented:</p>
<div> $$
\{ 3, 1, 4, 2 \} \; \leftrightarrow \; \begin{matrix}
- &amp; - &amp; Q &amp; - \\\
Q &amp; - &amp; - &amp; - \\\
- &amp; - &amp; - &amp; Q \\\
- &amp; Q &amp; - &amp; -
\end{matrix}
$$ </div>

<p><br></p>
<p>So let's say we write down a permutation where laying down the $i^{\rm th}$ queen causes us to create an invalid configuration.  For example, if we have $N = 6$ queens and the first 3 queens are $1, 5,$ and $4$,</p>
<div> $$
\{ 1, 5, 4, ?, ?, ? \} \; \leftrightarrow \; \begin{matrix}
Q &amp; - &amp; - &amp; - &amp; - &amp; - \\\
- &amp; - &amp; - &amp; - &amp; Q &amp; - \\\
- &amp; - &amp; - &amp; Q &amp; - &amp; - \\\
- &amp; ? &amp; ? &amp; - &amp; - &amp; ? \\\
- &amp; ? &amp; ? &amp; - &amp; - &amp; ? \\\
- &amp; ? &amp; ? &amp; - &amp; - &amp; ? \\\
\end{matrix}
$$ </div>

<p><br></p>
<p>We know that we can throw out all permutations that start with this sequence -- we don't need to generate any more elements of the permutation!  We can save ourselves from generating the 6 possible permutations that start this way.  This is exactly what the branch-swap algorithm is doing: if at the $i^{\rm th}$ index we generate a permutation that will not give a valid solution, we can pull the emergency brake and not generate <em>any</em> permutations with those first $i$ indices (other than the one we've already tested).  Formally, we terminate the given branch of the recursion.</p>
<p>Of course, the branch-swap permutation algorithm isn't the only one that has the property that it generates sequences of permutations this way.  For example, generating lexicographically-ordered permutations has this same property.  However, the branch-swap algorithm easily encodes the critical feature that it can bypass unwanted permutations by terminating the relevant branch of the recursion.</p>
<p>To tackle the $N$ queens problem, we need a way to check that a given queen is not attacking any others.  Actually, all we'll need is to check that it's not attacking any queen on a lower row, since we'll build a solution by recursively calling this check function as we go.  Here's the function:</p>
<pre class="code literal-block"><span class="c"># function to determine if a given queen (with a given index)</span>
<span class="c"># is not attacking any other queen with a lower index</span>
<span class="k">def</span> <span class="nf">is_safe</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
   <span class="n">dL_index</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="n">index</span>
   <span class="n">dR_index</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="n">index</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
      <span class="n">dL_i</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span>
      <span class="n">dR_i</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dL_index</span> <span class="o">==</span> <span class="n">dL_i</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dR_index</span> <span class="o">==</span> <span class="n">dR_i</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">False</span>
   <span class="c"># if we get here, there's no attacks</span>
   <span class="k">return</span> <span class="bp">True</span>
</pre>


<p><br></p>
<p>We use the fact that the left and right diagonals have either the same value of <code>row + column</code> or <code>row - column</code>.  We could do this comparison more pythonically:</p>
<pre class="code literal-block"><span class="c"># function to determine if a given queen (with a given index)</span>
<span class="c"># is not attacking any other queen with a lower index</span>
<span class="k">def</span> <span class="nf">is_safe</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
   <span class="k">return</span> <span class="p">(</span><span class="n">perm</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">)])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">perm</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">)])</span>
</pre>


<p><br></p>
<p>Then we just need to modify the permutation algorithm above to stop at a given branch when this function fails:</p>
<pre class="code literal-block"><span class="c"># N queens problem</span>
<span class="k">def</span> <span class="nf">nqueens</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
   <span class="n">base</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
   <span class="c"># counter for the number of solutions we try</span>
   <span class="n">ntries</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
   <span class="nb">next</span><span class="p">(</span><span class="n">ntries</span><span class="p">)</span>
   <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">explore</span><span class="p">(</span><span class="n">ntries</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
      <span class="k">yield</span> <span class="n">p</span>
   <span class="k">print</span> <span class="nb">next</span><span class="p">(</span><span class="n">ntries</span><span class="p">),</span><span class="s">"solutions tried"</span>

<span class="c"># branch-swap permtuation algorithm, recursion function</span>
<span class="c"># adapted for N queens problem</span>
<span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">ntries</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
   <span class="c"># if we're at the last index, check the last row and end the branch</span>
   <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">is_safe</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
         <span class="k">yield</span> <span class="n">perm</span>
      <span class="k">return</span>
   <span class="c"># create all single swaps at index with equal or greater indices</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
      <span class="n">perm_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
      <span class="n">perm_i</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">perm_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
      <span class="nb">next</span><span class="p">(</span><span class="n">ntries</span><span class="p">)</span>
      <span class="c"># check the diagonals for all smaller indices</span>
      <span class="k">if</span> <span class="n">is_safe</span><span class="p">(</span><span class="n">perm_i</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
         <span class="c"># call the recursion with the next index</span>
         <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">explore</span><span class="p">(</span><span class="n">ntries</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">perm_i</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">p</span>
</pre>


<p><br></p>
<p>I've also added a counter for the number of solutions we try.  We can do the same using the original branch-swap algorithm described first, and compare.  It's also useful to compare to $n!$, the number of configurations we'd have to try in the brute force case.</p>
<p>I've coded up this algorithm in both <code>python</code> and <code>C++</code>, and you can find them on my <a href="https://github.com/jrwalsh1/Permutations" title="Permutations">GitHub repo</a> for this project.  To get the solutions through $N = 16$, I used the <code>C++</code> version which runs in about 20 minutes on my laptop.  Scaling out, it would take about 2.5 hours for $N = 17$, and about 19 hours for $N = 18$!  I haven't tried to optimize the code, but the runtime is similar to the main <a href="http://rosettacode.org/wiki/N-queens_problem#C.2B.2B" title="Rosetta C++ solution for N queens">C++ solution on Rosetta Code</a>, once you take into account the multithreading in that code.  A <a href="http://rosettacode.org/wiki/N-queens_problem#Alternate_Fortran_77_solution" title="Fortran solution on Rosetta Code">Fortran 77 version on Rosetta Code</a> based on the same ideas is far faster, by at least an order of magnitude!  And <code>python</code> is about an order of mangitude slower than <code>C++</code>.</p>
<p>Here's a table of the number of solutions and tries for all 3 algorithms:
<br></p>
<table>
<thead><tr>
<th>N</th>
<th>   solutions</th>
<th>   branch-swap tries</th>
<th>   straight branch-swap tries</th>
<th>   brute force tries</th>
</tr></thead>
<tbody>
<tr>
<td>4</td>
<td>   2</td>
<td>   17</td>
<td>   29</td>
<td>   24</td>
</tr>
<tr>
<td>5</td>
<td>   10</td>
<td>   57</td>
<td>   90</td>
<td>   120</td>
</tr>
<tr>
<td>6</td>
<td>   4</td>
<td>   207</td>
<td>   317</td>
<td>   720</td>
</tr>
<tr>
<td>7</td>
<td>   40</td>
<td>   833</td>
<td>   1252</td>
<td>   5040</td>
</tr>
<tr>
<td>8</td>
<td>   92</td>
<td>   3543</td>
<td>   5197</td>
<td>   40320</td>
</tr>
<tr>
<td>9</td>
<td>   352</td>
<td>   15969</td>
<td>   22946</td>
<td>   362880</td>
</tr>
<tr>
<td>10</td>
<td>   724</td>
<td>   75189</td>
<td>   105965</td>
<td>   3628800</td>
</tr>
<tr>
<td>11</td>
<td>   2680</td>
<td>   382111</td>
<td>   531242</td>
<td>   39916800</td>
</tr>
<tr>
<td>12</td>
<td>   14200</td>
<td>   2073751</td>
<td>   2847477</td>
<td>   479001600</td>
</tr>
<tr>
<td>13</td>
<td>   73712</td>
<td>   11868391</td>
<td>   16119268</td>
<td>   6227020800</td>
</tr>
<tr>
<td>14</td>
<td>   365596</td>
<td>   72287547</td>
<td>   97340005</td>
<td>   87178291200</td>
</tr>
<tr>
<td>15</td>
<td>   2279184</td>
<td>   467414973</td>
<td>   624908454</td>
<td>   1307674368000</td>
</tr>
<tr>
<td>16</td>
<td>   14772512</td>
<td>   3204457467</td>
<td>   4258873171</td>
<td>   20922789888000</td>
</tr>
</tbody>
</table>
<p><br>
You can see that the number of tries for the branch-swap algorithms is far below the brute force case, as expected.  Furthermore, the branch-swap algorithm is more efficient than the straight branch-swap algorithm, although as $N$ increases the relative difference decreases.  Additionally, since the straight branch-swap algorithm is faster on a per-trial basis, the difference between the two algorithms is minimal.  The number of solutions is only a fraction of the number of tries, and this fraction is decreasing as $N$ increases: our algorithm is becoming less and less efficient at finding solutions.  Let's look at some of these efficiencies:</p>
<div style="text-align: center;"><img src="../../images/Nqueens_Nsols.png" alt="efficiencies" width="700"></div>

<p><br></p>
<p>First, you can see from the red line that we are getting more and more efficient at not trying bad solutions: the ratio of the number of tries to $n!$ (the number of tries in the brute force case) is exponentially falling.  This translates to a huge time savings in the code, even if the solution still scales exponentially.  The relatively efficiency of the branch-swap algorithms in finding actual solutions among the ones tried is going down, although the figure indicates this ratio <em>may</em> be leveling off.  In the (unlikely) case where it did level off in the asymptotic limit, one could imagine trying to improve this ratio to move towards a constructive algorithm.  There's lots more to think about at this point, both in terms of code and algorithmic approaches! But for now I'll stop here.</p>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/c++/" rel="tag">c++</a></li>
            <li><a class="tag p-category" href="../../categories/chess/" rel="tag">chess</a></li>
            <li><a class="tag p-category" href="../../categories/combinatorics/" rel="tag">combinatorics</a></li>
            <li><a class="tag p-category" href="../../categories/permutations/" rel="tag">permutations</a></li>
            <li><a class="tag p-category" href="../../categories/python/" rel="tag">python</a></li>
            <li><a class="tag p-category" href="../../categories/recursion/" rel="tag">recursion</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../measuring-wind-speeds-from-flights/" rel="prev" title="Measuring Wind Speeds from Flights">Previous post</a>
            </li>
        </ul></nav></aside><section class="comments"><h2>Comments</h2>
                        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="mathanddata",
            disqus_url="http://jrwalsh1.github.io/posts/permutations-and-the-n-queens-problem/",
        disqus_title="Permutations and the N Queens Problem",
        disqus_identifier="cache/posts/permutations-and-the-n-queens-problem.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="//disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section></article><script>var disqus_shortname="mathanddata";(function(){var a=document.createElement("script");a.async=true;a.src="//"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
                <!--End of body content-->
            </div>
        </div> <!-- ./col -->
    </div> <!-- ./row -->
</div> <!-- ./container -->

<footer class="footer"><div class="container">
        <p class="text-muted">
            Contents © 2015         <a href="mailto:jrwalsh1@gmail.com">Jon Walsh</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a><br>This work by <a xmlns:cc="http://creativecommons.org/ns#" href="http://jrwalsh1.github.io" property="cc:attributionName" rel="cc:attributionURL">Jon Walsh</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
            
        </p>
    </div>
</footer><script src="../../assets/js/all-nocdn.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
